\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\author{Olaf Bernstein}
\title{ReVision Goals}

\begin{document}

\maketitle
The Goal of this project is the complete revision of my favourite concepts of programming languages. It will be primarily oriented around C++ concepts because its currently one of my favourite and most used programming languages. I'll also take some inspiration from other languages like GO.
\tableofcontents




\section{Why Not C++?}
So why not C++, well C++ might support a grate amount of features, heck you can even make thinks like an NES emulator at compile time, but it has gotten pretty messy lately. For Example, there are still trying to keep the C backwards compatibility, but have extremely many new features. Some serve the same purpose of the C equivalent, but are only there to support the new C++ features.




\section{Control Flow}


\subsection{\textit{while}}
1. If condition is false jmp 4. \\
2. Execute code block. \\
3. jmp 1. \\
4. Continue execution. \\
Syntax:
\begin{lstlisting}
while(condition)
{
	// Some code ...
}
\end{lstlisting}


\subsection{\textit{jmp}}
Will jump to the Lable that's specified.
\begin{lstlisting}
LABLE:
// Some code ...
jmp LABLE;
\end{lstlisting}
With the \textit{jmpif} keyword can also insert a optional condition.
\begin{lstlisting}
LABLE:
// Some code ...
jmpif(condition) LABLE;
\end{lstlisting}


\subsection{\textit{for}}
1. Execute initialization code. \\
2. If condition is false jmp 5. \\
3. Execute code. \\
4. Execute iterate code. \\
5. Continue execution. \\
\begin{lstlisting}
for(initialization; condition; iterate)
{
	// Some code ...
}
\end{lstlisting}


\subsection{\textit{switch}}
Generates a jump table that jumps to the cases where the value is the same as the variable value.
\begin{lstlisting}
switch(variable)
{
	case value_1:
	{
		// Some code ...
	}
	case value_2, value_3:
	// Some code ...

	default:
	// Some code ...
}
\end{lstlisting}


\subsection{\textit{if}}
1. If the condition is true execute next code block. \\
2. Optional else code block get executed if 1 is false. \\
Is also possible to stack if statements using else if's.
\begin{lstlisting}
if(condition_1)
{
	// Some code ...
}
else if(condition_2)
{
	// Some code ...
}
else
{
	// Some code ...
}
\end{lstlisting}


\subsection{\textit{do}}
1. Execute code block. \\
2. If condition is true jmp 1. \\
4. Continue execution. \\
Syntax:
\begin{lstlisting}
do
{
	// Some code ...
} while(condition);
\end{lstlisting}


\subsection{\textit{asm}}
The code block after the asm keyword will be executed as assembly code.
\begin{lstlisting}
asm
{
	mov eax, 2 ; ...
};
\end{lstlisting}




\section{Type Modifier}


\subsection{\textit{const}}
Can be used to make a type imitable.
On pointers it makes the pointer unable to point to a different memory position.
\begin{lstlisting}
const float pi = 3.14;
// float = 2;  Error this would be invalid syntax.

int a = 10;
int b = 21;
const * int ptr = &a;
// ptr = &b; Error this would be invalid syntax.
\end{lstlisting}


\subsection{'\textit{[]}'}
Indicates that the type is an array.
There are many different syntax styles:
\begin{lstlisting}
[10]int array0; // creates an array of size 10 with the type of \textit{int).

[10]int array1 = {
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
};
[]int array2 = { // The size of an array can be automaticly deduced.
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
};
// array1 and array2 have exactly the same value and size.

[256]int array3 = {
	[4] = 2, // Will set the 4th index to the value 2.
	[2,6] = 4, // Works with n indexes at one time.
	5 // Will set the next index in this case the 7th to 5.
};


[2][2]int array2d0 = { // You can also create array of arrays. And so on...
	{1, 2},
	{3, 4}
};
[][]int array2d1 = {
	{1, 2, 3, 4},
	{5, 6, 7, 8},
	{9, 10, 11, 12}
};
[][]int array2d2 = {
	[2] = {[1] = 2, [3,7] = 1},
	[4] = 7
};

\end{lstlisting}


\subsection{'\textit{[]!}'}
Vector


\subsection{'\textit{*}'}
Pointer


\subsection{'\textit{*!}'}
Unique Pointer


\subsection{Map}
[](int|char)


\section{Primitive Types}


\subsection{Integer}
\begin{tabular}{c|c|l}
signed			& unsigned			 	& Description\\ \hline \hline
\textit{byte}	& \textit{ubyte}		&  \\
\textit{int8}	& \textit{uint8}		& 8-Bit integer value. \\ \hline

\textit{short}	& \textit{ushort}		&  \\
\textit{int16}	& \textit{uint16}		& 16-Bit integer value. \\ \hline

\textit{int}	& \textit{uint}			&  \\
\textit{int32}	& \textit{uint32}		& 32-Bit integer value. \\ \hline

\textit{long}	& \textit{ulong}		&  \\
\textit{int64}	& \textit{uint64}		& 64-Bit integer value if 64 bits are available otherwise 32 bits. \\
				&						& Using this data type on an system which doesn't support 64 bits \\
				&						& will also grant an compiler Warning. \\
\end{tabular}


\subsection{Floating Point}

\begin{tabular}{c|l}
Type			& Description \\ \hline
\textit{float}	& IEEE-32 bit Floating Point. \\
\textit{double}	& IEEE-64 bit Floating Point. \\
\end{tabular}


\subsection{Character/String Types}


\begin{tabular}{c|l}
Type			& Description\\ \hline
\textit{utf8}	&  \\
\textit{char}	& 8-Bit unicode character. \\

\textit{utf16}	& 16-Bit unicode character. \\
\textit{utf32}	& 32-Bit unicode character. \\
\textit{wchar}	& Depending on implementation same as utf16 or utf32 type. \\
\end{tabular}




\section{Abstract Types}


\subsection{Composite Types}

\subsubsection{\textit{class}}
\subsubsection{\textit{struct}}
\subsubsection{\textit{enum}}
\subsubsection{\textit{union}}


\subsection{String}
\begin{tabular}{c|l}
Type				& Description\\ \hline \hline
\textit{u8string}	&  \\
\textit{string}		& Uses \textit{char} for each character. \\ \hline

\textit{wstring}	& Uses \textit{wchar} for each character. \\
\end{tabular}




\section{Operators}


\subsection{\textit{new}}


\subsection{\textit{delete}}




\section{Scope}


\subsection{\textit{namespace}}


\subsection{\textit{use}}
The scope of the code block gets reduced to the variables in the capture list.
\begin{lstlisting}
use x, y // Capture list
{
	// Some code ...
};
\end{lstlisting}
Optional you can return a variable just like in a function.
\begin{lstlisting}
z = use x, y // Capture list
{
	// Some code ...
	return val;
};
\end{lstlisting}




\section{Other}


\subsection{\textit{auto}}




\end{document}
